rule patch_references ( references * )
{
    local result ;
    for ref in $(references)
    {
        if [ MATCH "([/]boost[/][/])" : $(ref) ]
        {
            ref = [ MATCH "(.*)[/]boost[/][/](.*)" : $(ref) ] ;
            ref = $(ref[1])/boost/$(ref[2]) ;
        }
        else if [ MATCH "([.][.][/][.][.][/].*[/]build)[/][/]" : $(ref) ]
        {
            ref = [ MATCH "(.*)[.][.][/][.][.][/](.*)[/]build[/][/](.*)" : $(ref) ] ;
            ref = $(ref[1])/boost/$(ref[2])//$(ref[3]) ;
        }
        else if [ MATCH "([.][.][/][.][.][/].*[/]build)" : $(ref) ]
        {
            ref = [ MATCH "(.*)[.][.][/][.][.][/](.*)[/]build" : $(ref) ] ;
            ref = $(ref[1])/boost/$(ref[2]) ;
        }
        result += $(ref) ;
    }
    return $(result) ;
}

import modules ;

import project ;
rule project_find ( name : current-location )
{
    return [ modules.call-in [ CALLER_MODULE ] :
        __project_find__ [ patch_references $(name) ] : $(current-location)
        ] ;
}
IMPORT project : find : : __project_find__ ;
IMPORT $(__name__) : project_find : project : find ;
EXPORT project : find ;

import generate ;
import print ;
import build-system ;
import targets ;
import path ;
import feature ;

import boostcpp ;

path-constant BOOST_ROOT : . ;
constant BOOST_VERSION : {{{boost_version}}} ;
constant BOOST_JAMROOT_MODULE : $(__name__) ;

boostcpp.set-version $(BOOST_VERSION) ;

local DEP_INCLUDES = {{{deps.include_paths}}} ;
local LIBRARIES = {{{libraries}}} ;

project boost
:   requirements
    <define>BOOST_ALL_NO_LIB=1
    <tag>@$(__name__).tag
    <link>shared,<runtime-link>static:<build>no
    <toolset>como:<link>static
    <toolset>como-linux:<define>_GNU_SOURCE=1
    <include>$(DEP_INCLUDES)
    <include>$(LIBRARIES)/include
:   build-dir bin
:   default-build {{{variant}}}
    <target-os>{{{os}}}
    <address-model>{{{address_model}}}
    <architecture>{{{architecture}}}
;

rule tag ( name : type ? : property-set )
{
    return [ boostcpp.tag $(name) : $(type) : $(property-set) ] ;
}

rule boost-install ( libraries * )
{
    install stage : $(libraries) : <location>output ;
    module [ CALLER_MODULE ] { explicit stage ; }
}

module boostcpp
{
    IMPORT alias : alias : boostcpp : __alias__ ;
    rule alias ( name : sources * : requirements * : default-build * :
        usage-requirements * )
    {
        local LIBRARIES = {{{libraries}}} ;
        if $(sources) in libs/$(LIBRARIES)/build { sources = [ MATCH libs/(.*) : $(sources) ] ; }
        return [ __alias__ $(name) : $(sources) : $(requirements)
            : $(default-build) : $(usage-requirements) ] ;
    }
}

rule lib_target_usage ( properties * )
{
    properties = [ patch_references $(properties) ] ;
    local library = [ MATCH "CONAN_LIB_BUILD=(.*)" : $(properties:G=) ] ;
    local libraries = [ feature.get-values <library> : $(properties) ] ;
    if $(libraries)
    {
        libraries = [ MATCH "([/]boost[/].*)" : $(libraries) ] ;
        if $(libraries)
        {
            LIBRARY_USAGE($(library)) = <library>$(libraries) ;
        }
    }
}

rule lib_target (
    name : sources * : requirements * : default-build * : usage-requirements * )
{
    sources = [ patch_references $(sources) ] ;
    requirements = [ patch_references $(requirements) ] ;
    usage-requirements = [ patch_references $(usage-requirements) ] ;
    local caller = [ CALLER_MODULE ] ;
    IMPORT $(__name__) : lib_target_usage : $(caller) : lib_target_usage ;
    EXPORT $(caller) : lib_target_usage ;
    local usage = $(usage-requirements) ;
    local library = [ MATCH "($(LIBRARIES_BUILD:J=|))" : $(name) ] ;
    if $(library)
    {
        usage += <conditional>@lib_target_usage ;
    }
    # ECHO >>>>>>>>>> LIB $(name) :: $(sources) :: $(requirements)
    #    :: $(default-build) :: $(usage) <define>CONAN_LIB_BUILD=$(library) ;
    return [ modules.call-in $(caller) :
        __lib_target__ $(name) : $(sources) : $(requirements)
            : $(default-build) : $(usage) <define>CONAN_LIB_BUILD=$(library)
        ] ;
}
IMPORT : lib : : __lib_target__ ;
IMPORT $(__name__) : lib_target : : lib ;

LIBRARIES_BUILD = ;
for local library in $(LIBRARIES)
{
    if [ path.exists $(library)/build ]
    {
        use-project /boost/$(library) : $(library)/build ;
        LIBRARIES_BUILD += $(library) ;
    }
}

rule export-jamroot ( targets * : sources * : properties * )
{
    print.output $(targets[1]) ;
    print.text "import project ;" ;
    print.text "project /{{{name}}} ;" ;
    local dollar = "\$" ;
    for local library in {{{libraries}}}
    {
        local usage = "$(LIBRARY_USAGE($(library)):J= )" ;
        print.text "project.register-id /boost/$(library) : $(dollar)(__name__) ;" ;
        print.text "lib boost_$(library) : : <name>boost_$(library) <search>. : : $(usage:E=) ;" ;
    }
    print.text "" ;
}

make jamroot.jam : : @export-jamroot ;

install export-jamroot : jamroot.jam : <location>stage/lib ;

{{{deps_info}}}

boostcpp.declare-targets $(LIBRARIES_BUILD) ;

rule post-build ( ok ? )
{
    if forward in [ modules.peek : top-level-targets ]
    {
        if $(ok)
        {
            ECHO "The {{{name}}} C++ Library was successfully built!" ;
        }
    }
}
IMPORT $(__name__) : post-build : : $(__name__).post-build ;
build-system.set-post-build-hook $(__name__).post-build ;
